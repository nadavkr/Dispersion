\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsthm,amsmath,amssymb, mathabx}
\usepackage{fullpage}
\usepackage[ruled,noend,linesnumbered]{algorithm2e}     
\usepackage{enumerate,comment}
\usepackage{url}
\usepackage[capitalise]{cleveref}
\usepackage{todonotes}
\usepackage{tikz}
\usepackage[noadjust]{cite}

\usepackage{graphicx, subfigure}
\usepackage{array}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsfonts}

\usepackage{color}

%\usepackage{algorithm}      % http://ctan.org/pkg/algorithms
%\usepackage{algpseudocode}  % http://ctan.org/pkg/algorithmicx
\usetikzlibrary{trees}

%\pagestyle{plain}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\poly}{\text{poly}}

\newcommand{\Oh}{{O}}
\newcommand{\common}{\mathsf{common}}
\newcommand{\encode}{\mathcal{L}}
\newcommand{\position}{\mathsf{position}}
\newcommand{\leaves}{\mathsf{leaves}}
\newcommand{\diff}{\mathsf{diff}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\lightdepth}{\mathsf{lightdepth}}
\newcommand{{\appx}}[2][2]{\lfloor{#2}\rfloor _{#1}}
\newcommand{\pre}{\mathsf{pre}}
\newcommand{\lightrange}[1]{\mathsf{L}_{#1}}
\newcommand{\heavy}{\mathsf{heavy}}
\newcommand{\lightsize}{\mathsf{ligthsize}}
\newcommand{\apex}{\mathsf{apex}}
\newcommand{\size}{\mathsf{size}}
\newcommand{\NCA}{\mathsf{NCA}}
\newcommand{\nca}{\text{NCA}}
\newcommand{\NCSA}{\mathsf{NCSA}}
\newcommand{\NCH}{\mathsf{NCH}}
\newcommand{\pow}{\mathsf{pow}}
\newcommand{\distance}{\mathsf{d}}
\newcommand{\nil}{\mathsf{nil}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\children}{\mathsf{children}}
\newcommand{\parent}{\mathsf{parent}}

\newcommand{\dist}{\text{dist}}
\newcommand{\tlab}{L}
\newcommand{\tlabmax}{M}
\newcommand{\tlabbound}{\mathcal{M}}
\newcommand{\scheme}{A}
\newcommand{\allschemes}{\mathcal{A}}
\newcommand{\lightcount}{\lightdepth}
\newcommand{\ncadist}{\mathsf{NCA}\text{-}\mathsf{distance}}
\newcommand{\treeroot}{\mathsf{root}}
\newcommand{\collapsed}{\mathcal{C}}
\newcommand{\hphead}{\mathsf{head}}



% For cleverref compatibility
\newtheorem{theorem}{Theorem}[section]
\newtheorem{algo}{Algorithm}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\theoremstyle{definition}   
\newtheorem{definition}[theorem]{Definition}
\usepackage{authblk}
\theoremstyle{remark}
\newtheorem{example}[theorem]{Example}
\newtheorem*{claim}{Claim}
\newtheorem{case}{Case}

\newtheorem{property}[theorem]{Property}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}

\title{Dispersion on Trees}
\author[1]{}
\affil[1]{University of Haifa, Israel}


\date{}
\maketitle

\begin{abstract}
bla bla 
\end{abstract}

\section{Introduction}
\begin{definition}
\emph{Max-Min Dispersion Problem (MMDP)} Given a tree $T$ with non-negative edge lengths, and a natural number $p$, find a subset $P\subseteq V$ of size $p$ s.t $f(P)=min{\scriptscriptstyle \forall u,v\in P,u\neq v}d(u,v)$ is maximized.
\end{definition}
\begin{definition}
\emph{MMDP Feasibility Test} Given a MMDP instance and a number $\lambda\geq0$ decide if there exists a subset $P\subseteq V$ of size $p$ s.t $f(P)\geq\lambda$.
\end{definition}
\begin{definition}
\emph{Weighted Max-Min Dispersion Problem (WMMDP)} Given a tree $T$ with non-negative vertex weights, non-negative edge lengths, and a real number $w\geq0$, find a subset $P$ of the vertices of $T$ s.t $W(P)\geq w$ (where $W(P)$ is the sum of the weights of the vertices of $P$), and $f(P)$ is maximized.
\end{definition}
\begin{definition}
\emph{WMMDP Feasibility Test} Given a WMMDP instance and a number $\lambda\geq0$ decide if there exists a subset $P\subseteq V$ s.t $W(P)\geq w$ and $f(P)\geq\lambda$.
\end{definition}


\section{The unweighted case}
We first describe how to solve the feasibility test in linear time, and then use this algorithm to solve the MMDP.
\subsection{Linear algorithm for the MMDP Feasibility Test}
%\begin{algo} \label{unWeightedFeasibilityAlgo}
We show a recursive linear algorithm.
At each step of the recursion, we would like to provide the maximal valid solution for the current subtree, given some $\lambda$. I.e, we would like to return $P$, a maximal subset of the vertices of the subtree, s.t   $P\subseteq V$ of size $p$ s.t $f(P)\geq\lambda$.
We are given a root vertex $v$ and its children nodes $v_{1},v_{2},...,v_{k}$, and for each child we are given a valid solution for the MMDP feasibility test on its subtree. We would like to produce a valid solution for the feasibility test on $v\text{'s subtree}$.
Denote by $P_{1},...,P_{k}$ the solutions for the feasibility test on each subtree rooted at a child of $v$.
For any subtree of $T$ rooted at node $r$, and a valid solution $P$ for the MMDP feasibility test on the subtree, we call a node $u\in P$, s.t $d(r,u)\leq\frac{\lambda}{2}$, a \textcolor{blue}{blue} node of the subtree. We call the vertex in $P$ that is closest to $r$, but isn't blue, \textcolor{green}{green}.
Note that each $P_{i}$ contains at most one blue vertex and one green vertex.

\paragraph{The recursion step} Given $P_{1},...,P_{k}$, we would like to produce a solution for $v$'s subtree.
\begin{enumerate}
\item Put in $P$ all the vertices in $P_{1},...,P_{k}$, except for the blue vertices.
\item Take all blue nodes $u$ s.t $d(u,v)> \frac{\lambda}{2}$
\item Take $u'$, the blue node farthest from $v$ s.t $d(u',v)\leq \frac{\lambda}{2}$, if it exists, and if $d(u',x)\leq \lambda$, where $x$ is the closest node to the root $v$ we have chosen so far.
\item Decide weather to take $v$ (the root) to the solution by looking at the closest vertex to it we have already put in $P$.
\end{enumerate}

We start by putting in $P$ all the vertices in $P_{1},...,P_{k}$, except for the blue vertices.
Now we need to decide which blue nodes we should put in $P$ and if we take $v$. We would like to take as many blue nodes as we can, and still maintain a dispersion of $\lambda$.
Take all blue nodes $u$ s.t $d(u,v)> \frac{\lambda}{2}$, and also take $u'$, the blue node farthest from $v$ that does not maintain this, i.e $d(u',v)\leq \frac{\lambda}{2}$, if it exists. We can decide if we take $v$ to the solution in constant time by looking at the closest vertex to it we have already put in $P$.
%\end{algo}

\begin{definition}
\emph{Active and Inactive nodes} We will call a vertex $v$ of the tree \emph{inactive} if there is a vertex $u$ we already chose to be in $P$, s.t $d(u,v)<\lambda$. We will call $v$ \emph{active} if there is no such vertex $u$.
\end{definition}
\begin{lemma} \label{greenNodesLemma}
For any subtree of $T$ rooted at node $r$, let $u$ be the most distant active vertex from $r$ in the subtree. if $d(u,r)\ge\frac{\lambda}{2}$, then there exists a solution to the MMDP, for which $f(P)\leq\lambda$ and $u$ is in the solution.
\end{lemma}
\begin{proof}
Assume for contradiction that there is no solution $P$ for which $f(P)\leq\lambda$ s.t $u\in P$. We consider the stage of a Denote the closest vertex to $u$ in $P$ by $u'$. We assume that we cannot replace $u'$ with $u$ and still get a valid solution. This means that there is a vertex $x$, s.t $x\in P$ and $d(u,x)<\lambda$. 
We know that:
\corollary{\label{corol1} $d(r,u)\ge\frac{\lambda}{2}$ (by definition)}
\corollary{\label{corol2} $d(u,u')<\lambda$ (because otherwise we could definitely add $u$ to the solution as $u'$ is defined as closest to $u$ in $P$)}
\corollary{\label{corol3} $d(x,u')\ge\lambda$ (since $x$ and $u'$ are both in $P$)}
\corollary{\label{corol4} $d(x,u)<\lambda$ (by definition) $d(r,u)>d(r,u')$ (since otherwise $u$ is not the active vertex most distant from $r$).}
Let us look at the possible cases:
\begin{case} Both $u'$ and $x$ are in the subtree rooted at $r$:
$d(u,u')=d(u,r)+d(r,u')<\lambda$ (due to corollary \ref{corol2}) $\Rightarrow d(r,u')<\frac{\lambda}{2}$ (due to corollary \ref{corol1}, and to the fact that by definition $u$ is closer to $r$ than $u'$), and similarly $d(r,x)<\frac{\lambda}{2} \Rightarrow d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}. 
\end{case}
\begin{case} $u'$ is in the subtree, and $x$ is not:
This means that the paths from $u$ and $u'$ to $x$ go through $r$. We have that $d(r,u)>d(r,u')$ (since otherwise $u$ is not the active vertex most distant from $r$), which implies that $d(r,u)+d(r,x)>d(r,u')+d(r,x)\Rightarrow d(u,x)>d(u',x)$ in contradiction to corollary \ref{corol3} and corollary \ref{corol4}.
\end{case}
\begin{case} $x$ is in the subtree and $u'$ is not:
We have that $d(r,u)>d(r,x)$ (since otherwise $u$ is not the active vertex most distant from $r$), and corollary \ref{corol2} implies that $d(u',r)+d(r,u)<\lambda$, so we get that $d(u',r)+d(r,x)<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} Both $x$ and $u'$ are not in the subtree:
\begin{case} $x$ is on the path from $u$ to $u'$:
We have that $d(u,u')=d(u,r)+d(r,x)+d(x,u')<\lambda\,\,\Rightarrow\,\,d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} $u'$ is on the path from $u$ to $x$:
We have that $d(u,x)=d(u,r)+d(r,u')+d(u',x)<\lambda\Rightarrow d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} neither $u'$ is on the path from $u$ to $x$ nor $x$ is on the path from $u$ to $u'$:
$d(u,x)=d(x,r)+d(r,u)<\lambda\Rightarrow(\text{by 1) }d(x,r)\le\frac{\lambda}{2}$ and similarly we get that $d(u',r)\le\frac{\lambda}{2}\,\,\,\Rightarrow\,\,\,d(u',x)\le\lambda$. 
\end{case}
\end{case}
\end{proof}
Lemma \ref{greenNodesLemma} implies the correctness of the algorithm.
%TODO extend proof of correctness

\subsection{Sublinear feasibility test for the MMDP}
%TODO

\subsection{Linear time solution for the MMDP}
The general idea of the algorithm is using the heavy path decomposition 

To find the smallest "good" $\lambda$, we proceed in log(n) phases. The phases are guided with the heavy path decomposition of the tree. In the i-th phase we process all heavy paths at level i (i.e., whose heads have subtrees of size $[2^i,2^{i+1})$). We maintain the current interval $[\lambda_1,\lambda_2)$ with the property that $\lambda^* \in [\lambda_1,\lambda_2)$, and furthermore for any $\lambda \in [\lambda_1,\lambda_2)$ there is a largest cardinality solution for the whole tree which is consistent with decision made in every subtree of size $<2^{i+1}$. "Consistent" here means that in every subtree we have a partial solution, i.e., a subset of nodes, and only one of these nodes we are not fully sure about. From the remaining nodes only the nearest to the root of the subtree matters, so again we keep a blue and a green node. The distance between the blue and green (if both exist) is $\geq \lambda$ for any $\lambda$ in the current interval, and we for sure take the blue and possibly also the green.

Increase i by one. Then, because we have determined $\lambda^*$ with sufficient accuracy, each subtree hanging off a heavy path at level i can be replaced by its blue and green node attached by single edges to the heavy path. Hence each such heavy path is a caterpillar.

Consider a single caterpillar on k nodes. Let the i-th leaf be connected with an edge of length $y_i$ to a node at distance $x_i$ from the root of the caterpillar. Order the leaves so that $x_1 < x_2 < ... < x_k$. I want to claim that we can first prune the caterpillar so that $y_i < \lambda/2$ for each $\lambda$ in the current interval. This should be clear (check), but I don't really know the value of $\lambda/2$ exactly, hence I need to further narrow down the current interval.

For this, choose the median of all $y_i$s, run the feasibility test, repeat on the remaining medians. This is $O(logk)$ feasibility tests and $O(k)$ time for the bookkeeping, and now the current interval is sufficiently small so that we know if $y_i < \lambda/2$.

I want to further prune the caterpillar so that $x_i+y_i$ is nondecreasing. Consider $i$ and choose $j < i$ such that $x_j+y_j$ is maximized, see the figure. Assume that $x_j+y_j > x_i+y_i$. Then, by $y_j \leq \lambda/2$, the distance between the i-th and the j-th leaf is $\leq \lambda$ (check). So optimal solution contains at most one of them, assume that it is the i-th. Replace it with the j-th there. The solution is still valid (check), so in fact we can remove the i-th leaf from the caterpillar.

Such pruning can be done in O(k) time by scanning the caterpillar bottom-up and maintaining a stack of "alive" leaves. Now it seems to me that I can repeat the reasoning in the other direction: prune the caterpillar so that $x_i-y_i$ is non-decreasing (imagine flipping the legs in the other direction) also in O(k) and without breaking the optimal solution. 

I have obtained a very structured caterpillar. In particular, now I can create a row- and column-sorted matrix storing all pairwise distance between the leaves, because for j<i the distance between the leaves is $y_i+y_j+x_i-x_j = (x_i+y_i) - (x_j-y_i)$, so arranging the matrix in the natural order gives monotone rows and columns. I can also create a sorted list containing the distances from every leaf to the head of the caterpillar. Then I run Frederickson's searching algorithm on such sorted matrices, in each of the log(n) steps (check if he is really using only that many steps) calling the feasibility test. This allows me to to run the blue-green reduction on the whole caterpillar I think (because other way to view it is: find the largest cardinality solution, and if there is a tie maximize the distance to the nearest chosen node).



\bibliographystyle{plain}
\bibliography{dispersion}



\end{document}