\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsthm,amsmath,amssymb, mathabx}
\usepackage{fullpage}
\usepackage[ruled,noend,linesnumbered]{algorithm2e}     
\usepackage{enumerate,comment}
\usepackage{url}
\usepackage[capitalise]{cleveref}
\usepackage{todonotes}
\usepackage{tikz}
\usepackage[noadjust]{cite}

\usepackage{graphicx, subfigure}
\usepackage{array}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsfonts}

\usepackage{color}

%\usepackage{algorithm}      % http://ctan.org/pkg/algorithms
%\usepackage{algpseudocode}  % http://ctan.org/pkg/algorithmicx
\usetikzlibrary{trees}

%\pagestyle{plain}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\poly}{\text{poly}}

\newcommand{\Oh}{{O}}
\newcommand{\common}{\mathsf{common}}
\newcommand{\encode}{\mathcal{L}}
\newcommand{\position}{\mathsf{position}}
\newcommand{\leaves}{\mathsf{leaves}}
\newcommand{\diff}{\mathsf{diff}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\lightdepth}{\mathsf{lightdepth}}
\newcommand{{\appx}}[2][2]{\lfloor{#2}\rfloor _{#1}}
\newcommand{\pre}{\mathsf{pre}}
\newcommand{\lightrange}[1]{\mathsf{L}_{#1}}
\newcommand{\heavy}{\mathsf{heavy}}
\newcommand{\lightsize}{\mathsf{ligthsize}}
\newcommand{\apex}{\mathsf{apex}}
\newcommand{\size}{\mathsf{size}}
\newcommand{\NCA}{\mathsf{NCA}}
\newcommand{\nca}{\text{NCA}}
\newcommand{\NCSA}{\mathsf{NCSA}}
\newcommand{\NCH}{\mathsf{NCH}}
\newcommand{\pow}{\mathsf{pow}}
\newcommand{\distance}{\mathsf{d}}
\newcommand{\nil}{\mathsf{nil}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\children}{\mathsf{children}}
\newcommand{\parent}{\mathsf{parent}}

\newcommand{\dist}{\text{dist}}
\newcommand{\tlab}{L}
\newcommand{\tlabmax}{M}
\newcommand{\tlabbound}{\mathcal{M}}
\newcommand{\scheme}{A}
\newcommand{\allschemes}{\mathcal{A}}
\newcommand{\lightcount}{\lightdepth}
\newcommand{\ncadist}{\mathsf{NCA}\text{-}\mathsf{distance}}
\newcommand{\treeroot}{\mathsf{root}}
\newcommand{\collapsed}{\mathcal{C}}
\newcommand{\hphead}{\mathsf{head}}



% For cleverref compatibility
\newtheorem{theorem}{Theorem}[section]
\newtheorem{algo}{Algorithm}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\theoremstyle{definition}   
\newtheorem{definition}[theorem]{Definition}
\usepackage{authblk}
\theoremstyle{remark}
\newtheorem{example}[theorem]{Example}
\newtheorem*{claim}{Claim}
\newtheorem{case}{Case}
\newtheorem{step}{Step}

\newtheorem{property}[theorem]{Property}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}

\title{Dispersion on Trees}
\author[1]{}
\affil[1]{University of Haifa, Israel}


\date{}
\maketitle

\begin{abstract}
bla bla 
\end{abstract}

\section{Introduction}
\begin{definition}
\emph{Max-Min Dispersion Problem (MMDP)} Given a tree $T$ with non-negative edge lengths, and a natural number $p$, find a subset $P\subseteq V$ of size $p$ s.t $f(P)=min{\scriptscriptstyle \forall u,v\in P,u\neq v}d(u,v)$ is maximized.
\end{definition}
\begin{definition}
\emph{MMDP Feasibility Test} Given a MMDP instance and a number $\lambda\geq0$ decide if there exists a subset $P\subseteq V$ of size $p$ s.t $f(P)\geq\lambda$.
\end{definition}
\begin{definition}
\emph{Weighted Max-Min Dispersion Problem (WMMDP)} Given a tree $T$ with non-negative vertex weights, non-negative edge lengths, and a real number $w\geq0$, find a subset $P$ of the vertices of $T$ s.t $W(P)\geq w$ (where $W(P)$ is the sum of the weights of the vertices of $P$), and $f(P)$ is maximized.
\end{definition}
\begin{definition}
\emph{WMMDP Feasibility Test} Given a WMMDP instance and a number $\lambda\geq0$ decide if there exists a subset $P\subseteq V$ s.t $W(P)\geq w$ and $f(P)\geq\lambda$.
\end{definition}


\section{The unweighted case}
We first describe how to solve the feasibility test in linear time, and then use this algorithm to solve the MMDP.
\subsection{Linear algorithm for the MMDP Feasibility Test}
%\begin{algo} \label{unWeightedFeasibilityAlgo}
We show a recursive linear algorithm.
At each step of the recursion, we would like to provide the maximal valid solution for the current subtree, given some $\lambda$. I.e, we would like to return $P$, a maximal subset of the vertices of the subtree, s.t   $P\subseteq V$ of size $p$ s.t $f(P)\geq\lambda$.
We are given a root vertex $v$ and its children nodes $v_{1},v_{2},...,v_{k}$, and for each child we are given a valid solution for the MMDP feasibility test on its subtree. We would like to produce a valid solution for the feasibility test on $v\text{'s subtree}$.
Denote by $P_{1},...,P_{k}$ the solutions for the feasibility test on each subtree rooted at a child of $v$.
For any subtree of $T$ rooted at node $r$, and a valid solution $P$ for the MMDP feasibility test on the subtree, we call a node $u\in P$, s.t $d(r,u)\leq\frac{\lambda}{2}$, a \textcolor{blue}{blue} node of the subtree. We call the vertex in $P$ that is closest to $r$, but isn't blue, \textcolor{green}{green}.
Note that each $P_{i}$ contains at most one blue vertex and one green vertex.

\paragraph{The recursion step} Given $P_{1},...,P_{k}$, we would like to produce a solution for $v$'s subtree.
\begin{enumerate}
\item Put in $P$ all the vertices in $P_{1},...,P_{k}$, except for the blue vertices.
\item Take all blue nodes $u$ s.t $d(u,v)> \frac{\lambda}{2}$
\item Take $u'$, the blue node farthest from $v$ s.t $d(u',v)\leq \frac{\lambda}{2}$, if it exists, and if $d(u',x)\leq \lambda$, where $x$ is the closest node to the root $v$ we have chosen so far.
\item Decide weather to take $v$ (the root) to the solution by looking at the closest vertex to it we have already put in $P$.
\end{enumerate}
%\end{algo}

\begin{definition}
\emph{Active and Inactive nodes} We will call a vertex $v$ of the tree \emph{inactive} if there is a vertex $u$ we already chose to be in $P$, s.t $d(u,v)<\lambda$. We will call $v$ \emph{active} if there is no such vertex $u$.
\end{definition}
\begin{lemma} \label{greenNodesLemma}
For any subtree of $T$ rooted at node $r$, let $u$ be the most distant active vertex from $r$ in the subtree. if $d(u,r)\ge\frac{\lambda}{2}$, then there exists a solution to the MMDP, for which $f(P)\leq\lambda$ and $u$ is in the solution.
\end{lemma}
\begin{proof}
Assume for contradiction that there is no solution $P$ for which $f(P)\leq\lambda$ s.t $u\in P$. We consider the stage of a Denote the closest vertex to $u$ in $P$ by $u'$. We assume that we cannot replace $u'$ with $u$ and still get a valid solution. This means that there is a vertex $x$, s.t $x\in P$ and $d(u,x)<\lambda$. 
We know that:
\corollary{\label{corol1} $d(r,u)\ge\frac{\lambda}{2}$ (by definition)}
\corollary{\label{corol2} $d(u,u')<\lambda$ (because otherwise we could definitely add $u$ to the solution as $u'$ is defined as closest to $u$ in $P$)}
\corollary{\label{corol3} $d(x,u')\ge\lambda$ (since $x$ and $u'$ are both in $P$)}
\corollary{\label{corol4} $d(x,u)<\lambda$ (by definition) $d(r,u)>d(r,u')$ (since otherwise $u$ is not the active vertex most distant from $r$).}
Let us look at the possible cases:
\begin{case} Both $u'$ and $x$ are in the subtree rooted at $r$:
$d(u,u')=d(u,r)+d(r,u')<\lambda$ (due to corollary \ref{corol2}) $\Rightarrow d(r,u')<\frac{\lambda}{2}$ (due to corollary \ref{corol1}, and to the fact that by definition $u$ is closer to $r$ than $u'$), and similarly $d(r,x)<\frac{\lambda}{2} \Rightarrow d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}. 
\end{case}
\begin{case} $u'$ is in the subtree, and $x$ is not:
This means that the paths from $u$ and $u'$ to $x$ go through $r$. We have that $d(r,u)>d(r,u')$ (since otherwise $u$ is not the active vertex most distant from $r$), which implies that $d(r,u)+d(r,x)>d(r,u')+d(r,x)\Rightarrow d(u,x)>d(u',x)$ in contradiction to corollary \ref{corol3} and corollary \ref{corol4}.
\end{case}
\begin{case} $x$ is in the subtree and $u'$ is not:
We have that $d(r,u)>d(r,x)$ (since otherwise $u$ is not the active vertex most distant from $r$), and corollary \ref{corol2} implies that $d(u',r)+d(r,u)<\lambda$, so we get that $d(u',r)+d(r,x)<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} Both $x$ and $u'$ are not in the subtree:
\begin{case} $x$ is on the path from $u$ to $u'$:
We have that $d(u,u')=d(u,r)+d(r,x)+d(x,u')<\lambda\,\,\Rightarrow\,\,d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} $u'$ is on the path from $u$ to $x$:
We have that $d(u,x)=d(u,r)+d(r,u')+d(u',x)<\lambda\Rightarrow d(x,u')<\lambda$ in contradiction to corollary \ref{corol3}.
\end{case}
\begin{case} neither $u'$ is on the path from $u$ to $x$ nor $x$ is on the path from $u$ to $u'$:
$d(u,x)=d(x,r)+d(r,u)<\lambda\Rightarrow(\text{by 1) }d(x,r)\le\frac{\lambda}{2}$ and similarly we get that $d(u',r)\le\frac{\lambda}{2}\,\,\,\Rightarrow\,\,\,d(u',x)\le\lambda$. 
\end{case}
\end{case}
%TODO fix case nesting
\end{proof}
%TODO add a drawing for each case
Lemma \ref{greenNodesLemma} implies the correctness of the algorithm.
%TODO extend proof of correctness

\subsection{Sublinear feasibility test for the MMDP}
The idea is partitioning the tree to fragments and preprocessing them, so that in query time (for a feasibility test query) we can "skip" over most fragments in $O(1)$. We will assume the tree is binary, and provide justification for this later on.
\subsubsection{Tree Partitioning} We would like to have fragments of size $b=log^2n$, s.t each fragment will be connected to the rest of the tree by at most two vertices. Each fragment have at most $b$ vertices, and will be defined by its border vertices $u$ and $v$ s.t $v$ is a descendant of $u$, as in the figure. We call the path from $u$ to $v$, the fragment's \textit{spine}, and $v$'s subtree the \textit{hole} of the fragment. %TODO add figure
\begin{lemma}
For any binary tree on $n$ nodes and a parameter $b$ there is a
partition of the tree into $O(n/b)$ fragments of size at most $2b$.
\end{lemma}
\begin{proof}
Call a node $u$ \textit{large} if the size of its subtree is greater than b and \textit{small}
otherwise. Consider the tree $T_L$ induced by the large nodes of the original tree. For
each leaf in $T_L$, make each of its children a new fragment with no holes. This creates $O(n/b)$ fragments since each leaf of $T_L$ is the root of a subtree of size at least $b$ in the original tree, and so we have at most $O(n/b)$ leaves in $T_L$. The size of each of these fragments is at most $2b-1$, since we assume that the tree is binary.
Next, for every branching node in $T_L$, make it a fragment consisting of just one node. This also creates $O(n/b)$ fragments, since in any tree the number of branching nodes is at most the number of leaves. We could not have simply gone up the tree and cut fragments of size $b$, since this would create fragments with more than two boundary nodes.
Ignoring the fragments we have already created, we are left with nodes that form unary chains in $T_L$. Each of this nodes might also have a child that is a small node. We have $O(n/b)$ of these subgraphs. We scan each of these subgraphs' large nodes bottom-up, and greedily cut them. Clearly these fragments are of size at most $2b$, as this is where we choose to cut. Denote the size of subgraph $i$, as $b_i$. The number of fragments we created in this phase is $$\sum_{i=1}^{n/b} \frac{b_i}{b} +1 \leq \frac{n}{b}$$. In total we have created $O(n/b)$ fragments, each of which is of size at most $2b$.
\end{proof}



Consider a single fragment. Assume that we already know the solution
restricted to the subtree rooted at its hole and now want to extend
it. By "know the solution" we mean that we have already decided that
some nodes for sure belong to the solution and there is at most one
one (at distance $< \lambda/2$ from the hole) that we are not sure
about. All already taken nodes are at distance >= $\lambda/2$. This is
guaranteed by our blue-green procedure. Now we would like to run the
procedure on the fragment. To run the procedure, for sure we need to
know for any two nodes $u_1, u_2$ in the fragment whether $d(u_1,u_2) <=
\lambda$. It seems that we also need to know whether $d(u_1,u_2) <=
\lambda/2$, at least for $u_2$ being a descendant of $u_1$. As in the $1D$
solution, we first binary search over intra-fragment distances to
determine this. These distances can be captured, for each fragment, by
a collection of doubly-sorted matrices of total size $O(blogb)$. After
O(logb)=O(loglogn) iterations, we can determine this for most of the
fragments. Other fragments will be processed naively, from now on I
will ignore them.

So the setting is: for any pair of nodes $u_1, u_2$ inside the fragment
we know whether $d(u_1,u_2) <= \lambda/2$ and $d(u_1,u_2) <= \lambda$. We
also have two nodes attached to the hole, the one that is closer to it
might be still removed from the current solution, but the other
cannot. We want to run the blue-green procedure.

Here is the first trick: having to keep track of two nodes attached
to the hole is difficult. I claim that, in fact, it is enough to run
the blue-green procedure with only one node attached to the hole and
an additional boolean flag denoting whether we must include it in
the solution. As the output, the procedure returns the blue and the
green node, but if the boolean flag was set to false it also informs
us whether that extra node has been taken. Now, to deal with two
nodes, first run the procedure with the closer one and the boolean
flag set to false. If the extra node has been taken, then the other
node is irrelevant inside the fragment, and we only need to check if
it is maybe closer to the root of the fragment than the returned blue
node. Otherwise, run the procedure again with the other node and the
boolean flag set to true.

Now, the second trick: consider the spine connecting u (the root) and
v (the hole) and the subtrees hanging off from it. Because we have
already consider the intra-fragment distances, we have enough data to
run the blue-green procedure on these subtrees (irrespectively to what
is attached to the hole!). Then, the blue nodes can be used to prune
the green nodes. We also find the nearest blue node to the hole and to
the root. The former is used to check, after attaching a node to the
hole, if it can be included in the solution (if not and if we don't
need to take it, we don't take it i.e. proceed as if nothing was
attached to the hole; if we do need to take it we have a
contradiction, so this cannot happen). The latter is used to update
the blue node after having finished processing the fragment. So in
fact, we can reduce the situation to a caterpillar, where all leaves
are the green nodes of these hanging off subtrees.

Finally, the third trick: we already know that in a caterpillar wlog
we can include in the solution all legs at distance $>= \lambda/2$ from
the spine. We do so and prune (potentially also updating the nearest
blue node to the hole). Then, we use the "monotone" pruning rule to
remove some of the remaining legs and obtain the situation where the
distances of the legs to the hole are increasing as we climb up on the
spine (so we use the monotonicity in only one direction). We have two
cases:
1) the node attached to the hole must be included in the solution.
Then we binary search over the spine to find its suffix consisting of
leaves that are too close to the hole to be taken. This takes O(logb)
time in the query time. For each possible remaining prefix we process
the result, this can be done in a single top-down sweep over the spine
in O(b) time during the preprocessing stage (check).
2) the node attached to the hole might or might not be included in the
solution. We consider the next leaf (closest to the hole), call it
$\ell_k$ and let $v_k$ be its parent on the spine. Consider the situation
at $v_k$. If the attached node is closer to $v_k$ than $\ell_k$, then it can
be safely discarded. Otherwise, we can discard $\ell_k$. This reasoning
can be repeated, so in the end we should binary search for the largest
i such that all leaves $\ell_{i+1}, \ell_{i+2}, ..., \ell_k$ can be
discarded. Then, we check if the distance from $v_k$ to the attached
node is at least $\lambda/2$ and if so we take it, otherwise we don't.
If we do take it, we need to again binary search to find how many
leaves are blocked by it, then we have the remaining prefix of the
spine and we proceed as in 1).

It seem to me that the preprocessing is only O(nloglogn), not
$O(n(loglogn)^2)$: there are O(loglogn) iterations, in each of them we
run the naive feasibility test. There is also the additional
bookkeeping cost, which if I understand Frederickson's theorem
correctly would be $O(nloglogn)$ as well, because this is the total size
of all our small matrices. Accelerating this to $O(nlog^*n)$ is not that
trivial. I will try to fully understand his paper now.

\subsection{Linear time solution for the MMDP}
The general idea of the algorithm is using the heavy path decomposition. We are searching for $\lambda^*$, which is the distance between some two nodes in the tree, and the largest number for which the MMDP feasibility test would return true.
We go through the heavy path tree bottom-up, and process all heavy paths at a specific level in parallel, until we are left with a green and blue node for each of them. We maintain an interval $[\lambda_1,\lambda_2)$ s.t $\lambda^*$ is in the interval, that gets smaller and smaller throughout the run.

We now describe the processing of a heavy path. Notice that the traversal is bottom-up, so we have already processed all of its children in the heavy path tree. Because we have determined $\lambda^*$ with sufficient accuracy (i.e. reduced the size of the maintained interval), each subtree hanging off a heavy path can be replaced by its blue and green node attached by single edges to the heavy path. Hence each such heavy path is a caterpillar, with one or two children for each spine node. We would like to be able to find the green and blue nodes for this heavy path. The situation is illustrated in figure %TODO add a figure
Assume that the caterpillar has k nodes. Let the $i$-th leaf be connected by an edge of length $y_i$ to a spine node at distance $x_i$ from the root of the caterpillar. Order the leaves so that $x_1 < x_2 < ... < x_k$.

\begin{step}
\textbf{Find the blue nodes that will certainly not be taken:}
Some of the blue nodes can be ignored as they "collide" with green nodes. We start by finding the closest green node to each blue node. We can do this in linear time by scanning the caterpillar bottom-up, while saving for each blue, the closest green node below it and the distance to it. We the do the same scan from top to bottom, and get for each blue node the closest green node and the distance to it. Now we want to find the blue nodes that are too close to a green node. Find the median of the distances, run a feasibility test on it, and repeat for the remaining distances, while updating the interval. Delete all blue nodes for which the distance to the closest green node is smaller than $\lambda^*$.
Notice that we are only left with some of the blue nodes to consider, and for all of them it hold that $y_i < \lambda_1/2$, and from this point we can ignore the green nodes.
\end{step}
\begin{step}
\textbf{Prune the caterpillar so that $\pmb{x_i+y_i}$  is non-decreasing:}
Traverse the caterpillar from bottom to top. Observe the $i$-th leaf, $u$. Denote by $v$ the leaf above $u$, and let  $j=i-1$. Assume $x_j+y_j > x_i+y_i$ (i.e $v$ is farther from the root than $u$). We get that $x_i-x_j+y_i < y_j$. $d(u,v) = x_i-x_j+y_i+y_j < 2y_j < \lambda$. So an optimal solution cannot contain both $u$ and $v$. If $u$ is in the solution we can replace it with $v$. This is because $v$ is farther away from any node above it than $u$, and $u$ is closer to any node below it than $v$. Let $v'$ be a leaf node above $v$, then $d(v,v') - d(v',u) = y_j-(x_i-x_j)-y_i = x_j+y_j-(x_i+y_i) > 0$, and the reasoning for the second case is similar.
So in fact, we can remove the i-th leaf from the caterpillar.
\end{step}
\begin{step}
\textbf{Construct a row and column sorted matrix storing all pairwise distance in the caterpillar}
It is easy to see that arranging the matrix in the natural order will produce a triangular matrix with monotone rows and columns.
\end{step}
\begin{step}
\textbf{Run a searching algorithm on the sorted matrices of all the heavy paths}
We now use Frederickson's method to search our sorted matrix and eliminate its entries using $O(logk)$ calls to out feasibility test algorithm. We thus narrow down our interval to be $[\lambda_1,\lambda_2)$ where $\lambda_1$ and $\lambda_2$ are consecutive pairwise distances in the caterpillar (i.e there is no $x\in [\lambda_1,\lambda_2)$ s.t x is a pairwise distance in the caterpillar, and so we can mark a blue and a green node of the caterpillar that will be valid for any value of $\lambda^*$.  %TODO citation needed. explanation of the search?
\end{step}
%TODO justify the tree being binary
\paragraph{Complexity analysis }




\bibliographystyle{plain}
\bibliography{dispersion}



\end{document}